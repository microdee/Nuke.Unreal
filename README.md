# Nuke.Unreal
![](docs/nu_logo-250.png)

![](https://badgen.net/nuget/v/md.Nuke.Unreal)

Simplistic workflow for automating Unreal Engine project steps embracing [Nuke](https://nuke.build).

Nuke + Unreal Engine workflow provides a consistent way to work with UE4/5 tools reducing the chore it comes with 

## Usage

Nuke.Unreal is available as a Nuget package and you can just add it to your build project as usual (package ID is `md.Nuke.Unreal`)


1. <details><summary>Install Nuke for an Unreal project</summary>  
   
   ```
   > dotnet tool install Nuke.GlobalTool --global
   
   > nuke :setup
     select None for solution
     build project inside Nuke.Targets folder
   
   > nuke :add-package md.Nuke.Unreal
   ```
   
   </details>
2. Inherit your Build class from `UnrealBuild` instead of `NukeBuild`
3. No further boilerplate required, run `nuke --plan` to test Nuke.Unreal
4. ***(optional)*** Inherit `IPackageTargets` interface if you want to package the associated Unreal project
5. ***(optional)*** Inherit `IPluginTargets` interface for automating plugin development related steps.

Your bare-bones minimal Build.cs which will provide the default features of Nuke.Unreal should look like this:

```CSharp
// Build.cs
using namespace Nuke.Common;
using namespace Nuke.Unreal;

class Build : UnrealBuild
{
    public static int Main () => Execute<Build>(x => x.BuildEditor);
}
```

## Features:
* All what the great Nuke can offer
* Common UE4 build tasks (generate project files, build editor, cook, package, etc)
  ```
  > nuke generate
  > nuke build-editor
  > nuke cook
  > nuke package
  > nuke build --config Shipping
  > nuke build --config DebugGame Development --target-type Game --platform Android
  ```
* Prepare plugins for release in Marketplace
  ```
  > nuke make-release --for-marketplace
  ```
* Generate boilerplate code and scaffolding from [Scriban](https://github.com/scriban/scriban) templates so no editor needs to be opened
    ```
    > nuke new-actor --name MyActor
    > nuke new-plugin --name MyPlugin
    > nuke new-module --name MyModule
    etc...
    ```
* Pluggable way to define targets for reusable plugins and modules

## Breaking changes

### 1.0 → 1.1
* `ToProject` and `ToPlugin` → `ProjectPath` and `PluginPath`
* `TargetPlatform` → `Platform`
* `TargetEngineVersion` → `EngineVersion`
* `RunIn` and `ExecMode` has been replaced with proper Unreal compliant target names `TargetType` and `UnrealTargetType`
* `UnrealTool` and `UnrealToolOutput` has been replaced by proper Nuke `Tool` delegates
* More smaller things might be there, beware when updating

## Setting up for a project

Nuke.Unreal targets looks for the `*.uproject` file automatically and it will use the first one it finds. A `*.uproject` is required to be present even for plugin development (more on plugins below). Automatically found project files can be in the sub-folder tree of Nuke's root (which is the folder containing the `.nuke` temporary folder) or in parent folders of Nuke's root. If for any reason there are more than one or no `*.uproject` files in that area, the developer can specify an explicit location of the associated `*.uproject` file.

```CSharp
public override AbsolutePath ProjectPath => RootDirectory / ".." / "MyProject" / "MyProject.uproject";
```

Only one Unreal project is supported per Nuke.Unreal instance.

## Setting up for plugin development

Same is applicable when Nuke.Unreal is used for developing an Unreal Plugin for release. Of course Nuke.Unreal can work with multiple plugins in a project, but the `IPluginTargets` interface focuses only on one plugin. Again if the plugin is not trivially locatable then the developer can specify its location explicitly.

```CSharp
public AbsolutePath PluginPath => UnrealPluginsFolder / "MyPlugin" / "MyPlugin.uplugin";
```

### Additional Plugin Targets

However plugins which require some pre-processing might benefit from the very simple "Plugin Targets" pattern, which is just simple class-library C# projects, referencing Nuke.Unreal as a nuget, and define extra targets or functionality which can be used by the main Nuke installation for the project. Let's have this scaffolding as an example:

```
<project root>
  - .nuke
  - Nuke.Targets
    - _build.csproj
    - Build.cs (main build script)
  - Content, Build, etc...
  - Source
    - MyModule
      - <source files>
      - Nuke.Targets
        - MyModule.csproj
        - MyModule.cs
  - Plugins
    - MyPlugin
      - <regular plugin files>
      - Nuke.Targets
        - MyPlugin.csproj
        - MyPlugin.cs
  - MyUnrealProject.uproject
```

`MyModule.csproj` and `MyPlugin.csproj` were both simply generated by `dotnet new classlib --name ... --output ./Nuke.Targets` and then the `md.Nuke.Unreal` which brings in the core Nuke packages, was added to define targets. Of course the developer can manually add these project references to the main build project, but Nuke.Unreal provides `discover-plugin-targets` target, which seeks out C# projects inside `Nuke.Targets` folders, and add them to the main build project automatically. After calling `discover-plugin-targets`, the developer can use these plugin projects as any other regular .NET reference. In most cases the plugin projects define interfaces which has some targets declared with "default implementation", then these interfaces can be inherited by the main Build class. Nuke will see the new targets without further boilerplate.

```CSharp

// MyModule.cs
using namespace Nuke.Common;
using namespace Nuke.Unreal;
namespace Nuke.MyModule;

public interface IMyModuleTargets : INukeBuild
{
    Target Foo => _ => _
        .DependsOn<IPackageTargets>()
        .Executes(() {...});
}

// MyPlugin.cs
using namespace Nuke.Common;
using namespace Nuke.Unreal;
namespace Nuke.MyPlugin;

public interface IMyPluginTargets : INukeBuild
{
    Target Foo => _ => _
        .Before<UnrealBuild>(u => u.Generate, u => u.Build, u => u.BuildEditor)
        .Executes(() {...});
}

// Build.cs
using namespace Nuke.Common;
using namespace Nuke.Unreal;
using namespace Nuke.MyModule;
using namespace Nuke.MyPlugin;

class Build : UnrealBuild, IPackageTargets, IMyModuleTargets, IMyPluginTargets
{
    public static int Main () => Execute<Build>(x => x.BuildEditor);
}
```

While discovering plugin targets, C# projects inside a `Nuke.Targets` folder neighbouring a `.nuke` folder will be ignored.

### Custom UBT or UAT arguments

Nuke.Unreal supports passing custom arguments to UBT or UAT via `--ubt-args` or `--uat-args`. These are regular array properties exposed as Nuke target parameters. This means however that doing `--ubt-args -DisableUnity` wouldn't actually add `-DisableUnity` to the argument list. This happens bec
ause Nuke stops parsing the array argument when it hits a `-` character. For this reason Nuke.Unreal has a special escape mechanism where `~-` is replaced with `-`, or if the argument starts with `~` then that's also replaced with a `-`.

So doing `--ubt-args ~DisableUnity ~2022` will correctly pass arguments `-DisableUnity -2022` to UBT.

For convenience the sequence `''` is also replaced with a double quote `"` hopefully escaping command line parsers.

This is especially useful for doing temporary debugging with UBT and the compiler: (not an actual usecase)
```
> nuke build ... --ubt-args "~CompilerArguments=''/diagnostics:caret /P /C''" ~DisableUnity
> nuke build ... --ubt-args "~LinkerArguments=''/VERBOSE''"
> nuke build ... --ubt-args ~Preprocess
```

## Generators

### C# code generators for Unreal tools

UBT already has some generated goodies, however the big feature announcement will come when I'm finished with UAT.

### Unreal boilerplate templates

Nuke.Unreal provides some targets which creates boilerplate code for common Unreal entities, such as

* [x] Plugins
* [x] Modules
* [x] Unreal Object/Actor/Structs/Interfaces
* [ ] Slate widgets

without the need for opening the UE4 editor or extend heavy weight IDE's. These boilerplate targets work with Scriban templates. The path to these templates can be overridden in the actual Nuke build class in case a project requires further boilerplate. Example:

In any folder in your project
```
> nuke NewActor --name MyPreciousActor
```

This will generate MyPreciousActor.h and ~.cpp at their respective places (taking public and private folders into account) and the minimal actor class boilerplate for unreal.

Optional **Custom templates** folders are required to contain generator specific subfolders. If a subfolder doesn't exist for a generator the default will be used. Example:

Scaffolding:
* RootDirectory
  * Nuke.Targets
    * ...
    * Build.cs
  * ...
  * MyTemplates
    * Actor
    * Object

In `Nuke.Targets/Build.cs` override `TemplatesPath` property
```CSharp
public override AbsolutePath TemplatesPath { get; set; } = RootDirectory / "MyTemplates";
```

This way Actor and Object generators will have their project specific Scriban templates but the remaining generator types will use the default templates of Nuke.Unreal.
